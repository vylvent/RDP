name: RDP-client win11-arm

on:
  workflow_dispatch:

defaults:
  run:
    shell: pwsh

jobs:
  secure-rdp:
    runs-on: windows-11-arm
    timeout-minutes: 360

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure Core RDP settings
        run: |
          # Allow incoming RDP
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0 -Force

          # Compatibility: adjust NLA/SecurityLayer as needed (change for stronger security if desired)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'UserAuthentication' -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'SecurityLayer' -Value 0 -Force

          # Ensure firewall rule for RDP exists
          try { netsh advfirewall firewall delete rule name='RDP-Tailscale' 2>$null } catch {}
          netsh advfirewall firewall add rule name='RDP-Tailscale' dir=in action=allow protocol=TCP localport=3389

          # Restart RDP service
          Restart-Service -Name TermService -Force

      - name: Create or update RDP user from secrets
        env:
          RDP_USERNAME: ${{ secrets.RDP_USERNAME }}
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          if (-not $env:RDP_USERNAME -or -not $env:RDP_PASSWORD) {
            Write-Error 'RDP_USERNAME and/or RDP_PASSWORD secrets are not set.'
            exit 1
          }

          $username = $env:RDP_USERNAME
          $plain = $env:RDP_PASSWORD

          # Convert immediately to secure string and clear plaintext
          $securePass = ConvertTo-SecureString $plain -AsPlainText -Force
          $plain = $null
          [System.GC]::Collect()
          [System.GC]::WaitForPendingFinalizers()

          try {
            $existing = Get-LocalUser -Name $username -ErrorAction SilentlyContinue
            if ($existing) {
              Set-LocalUser -Name $username -Password $securePass -ErrorAction Stop
            } else {
              New-LocalUser -Name $username -Password $securePass -AccountNeverExpires -ErrorAction Stop
            }

            Add-LocalGroupMember -Group 'Remote Desktop Users' -Member $username -ErrorAction Stop
            Add-LocalGroupMember -Group 'Administrators' -Member $username -ErrorAction SilentlyContinue
          } catch {
            Write-Error "Failed to create or update local user: $_"
            exit 1
          }

      - name: Install Tailscale
        run: |
          $installerPath = Join-Path $env:TEMP 'tailscale-setup.exe'
          try {
            Invoke-WebRequest -Uri 'https://pkgs.tailscale.com/stable/tailscale-setup-latest.exe' -OutFile $installerPath -UseBasicParsing -ErrorAction Stop
            Start-Process -FilePath $installerPath -ArgumentList '/quiet' -Wait -ErrorAction Stop
          } catch {
            Write-Error "Failed to download or install Tailscale: $_"
            exit 1
          } finally {
            if (Test-Path $installerPath) { Remove-Item $installerPath -Force -ErrorAction SilentlyContinue }
          }

      - name: Bring Tailscale up (unattended)
        env:
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          if (-not $env:TAILSCALE_AUTH_KEY) {
            Write-Error 'TAILSCALE_AUTH_KEY secret is not set.'
            exit 1
          }

          $tailscaleExe = 'C:\Program Files\Tailscale\tailscale.exe'
          if (-not (Test-Path $tailscaleExe)) {
            Write-Error "Tailscale executable not found at $tailscaleExe"
            exit 1
          }

          & $tailscaleExe version || Write-Host 'tailscale version failed to run'
          Test-NetConnection -ComputerName pkgs.tailscale.com -Port 443 -InformationLevel Detailed | Out-Host

          try { Start-Service -Name Tailscale -ErrorAction Stop } catch { Write-Host "Start-Service returned: $_" }

          $serviceTimeout = 90
          $serviceTimer = [System.Diagnostics.Stopwatch]::StartNew()
          while ((Get-Service -Name Tailscale -ErrorAction SilentlyContinue).Status -ne 'Running') {
            if ($serviceTimer.Elapsed.TotalSeconds -ge $serviceTimeout) {
              Write-Error 'Timed out waiting for the Tailscale service to start.'
              Get-Service -Name Tailscale -ErrorAction SilentlyContinue | Format-List * | Out-String | Write-Host
              exit 1
            }
            Write-Host 'Waiting for Tailscale service to start...'
            Start-Sleep -Seconds 2
          }
          Write-Host 'Tailscale service is running.'

          # Use --auth-key and --unattended for non-interactive Windows runs (requires a reusable pre-auth key).
          $hostname = "gh-runner-$($env:GITHUB_RUN_ID)"
          $auth = $env:TAILSCALE_AUTH_KEY

          # --timeout expects a duration (e.g. "60s")
          & $tailscaleExe up --auth-key="$auth" --hostname="$hostname" --accept-routes --unattended --reset --timeout=60s 2>&1 | ForEach-Object { Write-Host $_ }

      - name: Keepalive & auto-recover (maintain connection for login)
        env:
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          # This step intentionally runs indefinitely to keep the runner available for RDP login.
          # It:
          #  - prevents sleep (best-effort),
          #  - ensures TermService and Tailscale service are running,
          #  - checks tailscale backend state and attempts a non-interactive up if it goes away,
          #  - prints the assigned Tailscale IP so you can RDP to it.
          $ErrorActionPreference = 'Continue'

          # Try to disable sleep/hibernate to keep session reachable (may be restricted on hosted runners)
          try {
            powercfg /change monitor-timeout-ac 0
            powercfg /change standby-timeout-ac 0
            powercfg /hibernate off
          } catch { Write-Host "powercfg adjust failed: $_" }

          $tailscaleExe = 'C:\Program Files\Tailscale\tailscale.exe'
          $auth = $env:TAILSCALE_AUTH_KEY
          $hostname = "gh-runner-$($env:GITHUB_RUN_ID)"

          function Ensure-ServiceRunning($name) {
            try {
              $svc = Get-Service -Name $name -ErrorAction SilentlyContinue
              if (-not $svc) {
                Write-Host "Service $name not found"
                return
              }
              if ($svc.Status -ne 'Running') {
                Write-Host "Starting service $name..."
                Start-Service -Name $name -ErrorAction SilentlyContinue
              }
            } catch {
              Write-Host "Ensure-ServiceRunning($name) failed: $_"
            }
          }

          function Tailscale-BackendState() {
            try {
              $raw = & $tailscaleExe status --json 2>$null
              if ($raw) {
                return ($raw | ConvertFrom-Json -ErrorAction Stop).BackendState
              }
            } catch { }
            return $null
          }

          function Tailscale-IPv4() {
            try {
              $ips = & $tailscaleExe ip -4 2>$null
              if ($ips) {
                $ip = ($ips -split '\s+' | Where-Object { $_ -match '\d+\.\d+\.\d+\.\d+' } | Select-Object -First 1)
                return $ip
              }
            } catch { }
            return $null
          }

          # Initial status print
          Ensure-ServiceRunning 'TermService'
          Ensure-ServiceRunning 'Tailscale'
          Start-Sleep -Seconds 2

          $initialState = Tailscale-BackendState
          Write-Host "Initial Tailscale backend state: $initialState"
          $tsIP = Tailscale-IPv4
          if ($tsIP) { Write-Host "Tailscale IP: $tsIP" } else { Write-Host "Tailscale IP not yet assigned" }

          # Loop forever, verify services and tailscale state, attempt unattended up if needed.
          $retryCount = 0
          while ($true) {
            Ensure-ServiceRunning 'TermService'
            Ensure-ServiceRunning 'Tailscale'

            $state = Tailscale-BackendState
            if (-not $state -or $state -ne 'Running') {
              Write-Host "Tailscale backend not Running (state='$state'). Attempting non-interactive up (retry #$retryCount)..."
              try {
                & $tailscaleExe up --auth-key="$auth" --hostname="$hostname" --accept-routes --unattended --reset --timeout=60s 2>&1 | ForEach-Object { Write-Host $_ }
              } catch {
                Write-Host "tailscale up attempt failed: $_"
              }
              $retryCount = $retryCount + 1
            } else {
              # If running, ensure we have an IP to tell you to connect to
              $tsIP = Tailscale-IPv4
              if ($tsIP) { Write-Host "Tailscale running: $tsIP" } else { Write-Host "Tailscale running but no IPv4 assigned yet" }
              $retryCount = 0
            }

            # If many retries fail, pause longer to avoid hammering control plane
            if ($retryCount -gt 6) {
              Write-Host "Multiple failures detected; sleeping longer before next attempt."
              Start-Sleep -Seconds 60
            } else {
              Start-Sleep -Seconds 20
            }
          }